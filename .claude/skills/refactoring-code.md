---
name: refactoring-code
description: 一連のタスクコーディング後に以下の開発設計ルールに基づいてリファクタリングを実施する
---

# リファクタリング実行手順

1. **変更箇所の確認**
   - `git status` と `git diff` で未コミット変更を確認
   - 変更されたファイルの一覧と変更内容を把握

2. **コード分析**
   - 変更されたファイルを読み込み、以下の観点で分析
     - 重複コードの有無
     - 関数の責務が適切か
     - 命名規則が統一されているか
     - ディレクトリ構造が適切か

3. **リファクタリング実施**
   - 検出された問題点を優先度順に修正
   - 各修正後、型エラーがないことを確認（`bunx tsc --noEmit`）
   - 必要に応じてコードレビューエージェントを起動

4. **最終確認**
   - すべてのチェックリスト項目を確認
   - 変更が最小限であることを確認

# 開発設計ルール

## 原則

- 関心を分離して影響範囲を限定する
- 高凝集にして内部変更を容易にする
- 疎結合にして依存関係を減らす
- 抽象化して変更耐性を高める
- 非冗長にして重複を排除する

## 構造

- 同一関心のファイルが 3 件以上になった場合は専用ディレクトリを作成し階層化する

## 実装指針

- シンプルを最優先とする
- オーバーエンジニアリング禁止
- 常に最小限で設計・実装する
- ファイルの細分化を避ける。過剰な場合は統合する

## コード品質

- [ ] コードが読みやすく構造化されている
- [ ] 関数が小さく焦点が絞られている
- [ ] 変数名が説明的
- [ ] コードの重複がない
- [ ] 利用されていない変数やファイルが存在しない
- [ ] Lintor エラーや TS エラーがない

## セキュリティ

- [ ] 明らかなセキュリティ脆弱性がない
- [ ] 入力検証が実装されている
- [ ] 機密データが適切に処理されている
- [ ] ハードコードされた秘密情報がない

## 運用

- 未コミット変更部分を重点的に確認

# リファクタリングパターン

## 検出すべきアンチパターン

### 1. 重複コード

- 同じまたは類似のコードブロックが複数箇所に存在
- 対応: 共通関数/コンポーネントへの抽出

### 2. 長大な関数

- 50行以上の関数、または複数の責務を持つ関数
- 対応: 単一責任の原則に基づき分割

### 3. 不適切な命名

- 変数名が `temp`, `data`, `result` などの汎用的な名前
- 対応: ビジネスロジックを反映した説明的な名前に変更

### 4. 過剰な階層化

- 同じ関心事で3ファイル未満なのにディレクトリが作られている
- 対応: フラットな構造に統合

### 5. 未使用のコード

- インポートされていない関数や変数
- 対応: 削除

### 6. マジックナンバー/文字列

- ハードコードされた数値や文字列
- 対応: 定数として定義

## 優先順位

1. セキュリティ上の問題（最優先）
2. 型エラー、Lintエラー
3. 重複コード
4. 命名の改善
5. 構造の最適化

## 注意事項

- 動作を変えない範囲でのみリファクタリングを実施
- 過度な抽象化は避ける（YAGNIの原則）
- リファクタリング後は必ず型チェックを実行する
